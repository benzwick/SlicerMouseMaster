#!/usr/bin/env python
"""Generate actions reference documentation from ActionRegistry.

This script introspects the ActionRegistry to generate RST documentation
for all available actions organized by category.

Requires Slicer context:
    Slicer --python-script MouseMaster/Testing/Python/test_generate_actions_reference.py \
        --additional-module-paths $(pwd)/MouseMaster

Output: docs/reference/_generated/actions.rst
"""

from __future__ import annotations

import os
import sys
from pathlib import Path


def get_project_root() -> Path:
    """Get the project root directory."""
    workspace = os.environ.get("GITHUB_WORKSPACE")
    if workspace:
        return Path(workspace)

    # From Testing/Python/, go up to MouseMaster/, then to project root
    return Path(__file__).parent.parent.parent.parent


def get_output_dir() -> Path:
    """Get the output directory for generated documentation."""
    return get_project_root() / "docs" / "reference" / "_generated"


def get_category_display_name(category: str) -> str:
    """Get human-readable display name for a category.

    Args:
        category: Internal category name

    Returns:
        Human-readable display name
    """
    category_names = {
        "editing": "Editing Actions",
        "navigation": "Navigation Actions",
        "segment_editor": "Segment Editor Actions",
        "markups": "Markups Actions",
        "volume_rendering": "Volume Rendering Actions",
        "slicer_menus": "Slicer Menu Actions",
    }

    # Handle dynamically discovered menu categories like "menu_file"
    if category.startswith("menu_"):
        menu_name = category.replace("menu_", "").replace("_", " ").title()
        return f"{menu_name} Menu Actions"

    return category_names.get(category, category.replace("_", " ").title() + " Actions")


def get_category_description(category: str) -> str:
    """Get description for a category.

    Args:
        category: Internal category name

    Returns:
        Category description
    """
    descriptions = {
        "editing": "Actions for editing operations like undo and redo.",
        "navigation": "Actions for view navigation and crosshair control.",
        "segment_editor": "Actions specific to the Segment Editor module. "
        "Only available when Segment Editor is active.",
        "markups": "Actions for markup and fiducial operations. "
        "Only available when Markups module is active.",
        "volume_rendering": "Actions for controlling volume rendering visibility.",
        "slicer_menus": "Actions discovered from Slicer's menu system.",
    }

    if category.startswith("menu_"):
        return "Actions from Slicer's menu system (discovered at runtime)."

    return descriptions.get(
        category, "Actions for " + category.replace("_", " ") + " functionality."
    )


def generate_actions_table(actions: list) -> list[str]:
    """Generate RST table for actions.

    Args:
        actions: List of ActionEntry objects

    Returns:
        List of RST lines for the table
    """
    lines = [
        ".. list-table::",
        "   :header-rows: 1",
        "   :widths: 30 50 20",
        "",
        "   * - Action ID",
        "     - Description",
        "     - Icon",
    ]

    for action in sorted(actions, key=lambda a: a.id):
        icon = action.icon if action.icon else "-"
        if icon != "-":
            icon = f"``{icon}``"

        lines.extend(
            [
                f"   * - ``{action.id}``",
                f"     - {action.description}",
                f"     - {icon}",
            ]
        )

    return lines


def generate_actions_rst() -> str:
    """Generate RST content for actions reference.

    Returns:
        RST content as string
    """
    # Import ActionRegistry (requires Slicer context)
    from MouseMasterLib.action_registry import ActionRegistry

    registry = ActionRegistry.get_instance()

    lines = [
        ".. This file is auto-generated by test_generate_actions_reference.py",
        ".. Do not edit manually",
        "",
    ]

    # Get all categories and their actions
    categories = registry.get_categories()

    # Define preferred category order
    category_order = [
        "editing",
        "navigation",
        "segment_editor",
        "markups",
        "volume_rendering",
    ]

    # Sort categories: preferred order first, then alphabetically
    def sort_key(cat: str) -> tuple:
        if cat in category_order:
            return (0, category_order.index(cat))
        return (1, cat)

    sorted_categories = sorted(categories, key=sort_key)

    for category in sorted_categories:
        # Skip menu categories from discovered actions (they clutter the docs)
        if category.startswith("menu_"):
            continue

        actions = registry.get_actions_by_category(category)
        if not actions:
            continue

        display_name = get_category_display_name(category)
        lines.append(display_name)
        lines.append("-" * len(display_name))
        lines.append("")

        description = get_category_description(category)
        lines.append(description)
        lines.append("")

        lines.extend(generate_actions_table(actions))
        lines.append("")
        lines.append("")

    # Add section about discovered actions
    lines.extend(
        [
            "Discovered Slicer Actions",
            "-------------------------",
            "",
            "MouseMaster can discover additional actions from Slicer's menu system at runtime.",
            "Use ``ActionRegistry.discover_slicer_actions()`` to populate the registry with",
            "all available QActions from Slicer's main window.",
            "",
            "These actions have IDs prefixed with ``slicer_menu_`` followed by the Qt object name.",
            "",
            "Example:",
            "",
            ".. code-block:: python",
            "",
            "   from MouseMasterLib.action_registry import ActionRegistry",
            "",
            "   registry = ActionRegistry.get_instance()",
            "   count = registry.discover_slicer_actions()",
            "   print(f'Discovered {count} menu actions')",
            "",
            "",
            "Custom Actions",
            "--------------",
            "",
            "You can define custom actions using:",
            "",
            "**Python Commands**",
            "",
            "Execute arbitrary Python code:",
            "",
            ".. code-block:: json",
            "",
            "   {",
            '     "action": "python_command",',
            '     "parameters": {',
            '       "command": "slicer.util.selectModule(\'SegmentEditor\')"',
            "     }",
            "   }",
            "",
            "**Keyboard Shortcuts**",
            "",
            "Simulate keyboard input:",
            "",
            ".. code-block:: json",
            "",
            "   {",
            '     "action": "keyboard_shortcut",',
            '     "parameters": {',
            '       "key": "Z",',
            '       "modifiers": ["ctrl"]',
            "     }",
            "   }",
            "",
            "See :doc:`/developer-guide/adding-actions` for details on creating custom actions.",
            "",
        ]
    )

    return "\n".join(lines)


def generate_actions_reference() -> Path:
    """Generate the actions reference documentation.

    Returns:
        Path to the generated file
    """
    output_dir = get_output_dir()
    output_dir.mkdir(parents=True, exist_ok=True)

    rst_content = generate_actions_rst()

    output_file = output_dir / "actions.rst"
    with open(output_file, "w") as f:
        f.write(rst_content)

    print(f"Generated: {output_file}")

    # Count actions for reporting
    from MouseMasterLib.action_registry import ActionRegistry

    registry = ActionRegistry.get_instance()
    total_actions = len(registry.get_all_actions())
    print(f"Actions documented: {total_actions}")

    return output_file


def test_generate_actions_reference():
    """Test that actions reference documentation can be generated."""
    output_file = generate_actions_reference()
    assert output_file.exists(), f"Output file not created: {output_file}"

    content = output_file.read_text()
    assert "edit_undo" in content, "edit_undo not in output"
    assert "Editing Actions" in content, "Editing Actions section not in output"
    assert ".. list-table::" in content, "Action table not in output"

    print("Test passed: actions reference documentation generated successfully")


if __name__ == "__main__":
    output_file = generate_actions_reference()

    # Print some of the output for verification
    print("\n" + "=" * 60)
    print("Generated content preview:")
    print("=" * 60)
    content = output_file.read_text()
    # Print first 60 lines
    for line in content.split("\n")[:60]:
        print(line)
    print("...")

    sys.exit(0)
